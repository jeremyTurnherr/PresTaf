%% Based on a TeXnicCenter-Template by Gyorgy SZEIDL.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%------------------------------------------------------------
%
\documentclass{article}%
%Options -- Point size:  10pt (default), 11pt, 12pt
%        -- Paper size:  letterpaper (default), a4paper, a5paper, b5paper
%                        legalpaper, executivepaper
%        -- Orientation  (portrait is the default)
%                        landscape
%        -- Print size:  oneside (default), twoside
%        -- Quality      final(default), draft
%        -- Title page   notitlepage, titlepage(default)
%        -- Columns      onecolumn(default), twocolumn
%        -- Equation numbering (equation numbers on the right is the default)
%                        leqno
%        -- Displayed equations (centered is the default)
%                        fleqn (equations start at the same distance from the right side)
%        -- Open bibliography style (closed is the default)
%                        openbib
% For instance the command
%           \documentclass[a4paper,12pt,leqno]{article}
% ensures that the paper size is a4, the fonts are typeset at the size 12p
% and the equation numbers are on the left side
%
\usepackage{amsmath}%
\usepackage{amsfonts}%
\usepackage{amssymb}%
\usepackage{graphicx}
\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,automata}
\usepackage{tkz-graph}
\usepackage{cite}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{     
	colorlinks,     
	linkcolor={black},     
	citecolor={black},     
	urlcolor={black} 
}
\usepackage[toc,section=section,nonumberlist]{glossaries}
\usepackage{url}
\makeglossaries
%-------------------------------------------
\newtheorem{theorem}{Theorem}
\newtheorem{acknowledgement}[theorem]{Acknowledgement}
\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{case}[theorem]{Case}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{conclusion}[theorem]{Conclusion}\newtheorem{condition}[theorem]{Condition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{criterion}[theorem]{Criterion}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{exercise}[theorem]{Exercise}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{solution}[theorem]{Solution}
\newtheorem{summary}[theorem]{Summary}
\newenvironment{proof}[1][Proof]{\textbf{#1.} }{\ \rule{0.5em}{0.5em}}

%--------------------------------------------------------------------%
%         POUR DEFINIR DES ENTRÉES DU GLOSSAIRE LE FAIRE ICI         %
%              POUR LES ACRONYMES C'EST AU MÊME ENDROIT              %
%--------------------------------------------------------------------%

\longnewglossaryentry{presburger}{
	name=Arithmétique de Presburger
}
{
	L'arithmétique de Presburger à été introduite par Moj\.{z}esz Presburger en 1929. Cette arithmétique du premier ordre dispose de deux constantes 0 et 1 ainsi qu'un symbole binaire +. Ce langage est limité aux entiers naturels et est défini par les lois suivantes :
	\begin{enumerate}
		\item $\forall x, \neg(0 = x + 1)$
		\item $\forall x, \forall y, x + 1 = y + 1 \rightarrow x = y $
		\item $\forall x, x + 0 = x$
		\item $\forall x, \forall y, x + (y + 1) = (x + y) + 1$
		\item $\forall P(x, y_1, \ldots, y_n) \in$ Formule du premier ordre, 
		$\forall y_1 \ldots \forall y_n [(P(0, y_1, \ldots,y_n) \vee \forall x(P(x, y_1, \ldots, y_n) \rightarrow P(x + 1, y_1, \ldots, y_n))) \rightarrow \forall y P(y, y_1, \ldots, y_n)]$
	\end{enumerate}
}

\longnewglossaryentry{monadique}{
	name=Logique monadique du second ordre
} {
	aussi connu sous le nom de \emph{Monadic Second Order} ou \emph{MSO}, est notamment utilisé dans un autre programme de M.Couvreur : VeriTaf. VeriTaf permet de vérifier des formules CTL (Computation Tree Logic) et des formules LTL (Linear Temporal Logic)
}

%--------------------------------------------------------------------%
%         POUR DEFINIR DES ENTRÉES DU GLOSSAIRE LE FAIRE ICI         %
%              POUR LES ACRONYMES C'EST AU MÊME ENDROIT              %
%--------------------------------------------------------------------%


\begin{document}

\title{Mémoire PresTaf}

\author{Bourgeois Adrien, Marbois Bryce, Roque Maxime, Turnherr Jérémy%\thanks{Si l'on veut faire des annotations.}
\\Université UFR Collégium des Sciences et Technique d'Orléans-la-Source}
\date{\today}
\maketitle

% \begin{abstract}

% \end{abstract}

\clearpage

\tableofcontents

\cleardoublepage

\section{Résumé du projet}

Notre projet s'inscrit dans la mis-à-jour de PresTaf, logiciel d'analyse de formules logique et de leur transformation en automate minimal. Nous intervenons ici dans la création d'un interfaçage Lua, ainsi qu'une reprise du code source PresTaf pour donner une version plus optimisé, plus claire et propre. Qui plus est, le Lua étant un langage basé sur le C++ cela offre la possibilité à l'utilisateur de surcharger des opérateurs. Ainsi il pourra utiliser les opérateurs pour écrire simplement ses formules logiques de façon simple.\\\par

Dans un second temps nous chercherons à intégrer de nouvelles logiques telle que la logique monadique ou encore l'interprétation des formules de Presburger en base -2.

\section{Domaine}

Le logiciel sur lequel on s'appuie pour notre travail de départ est PresTaf implementant en Java la logique \gls{presburger}\cite{ginsburg1966semigroups}. Il existe des logiciels concurrent travaillant avec d'autres logiques telle que la \gls{monadique}\cite{KlaEtAl:Mona} avec des logiciel comme Mona\cite{monamanual2001}, ou la logique arithmétique de Presburger et les d'autre logiques sur les mots infini avec Lash\cite{lash}.

\section{Analyse de l'existant}

PresTaf est un programme codé par M. Jean-Michel Couvreur, qui prend des formules de Presburger en entrées et les résout à l'aide d'automates minimaux. Tout d'abord il génère des automates déterministes et finis mais non minimaux. Il faut donc les minimiser, et pour se faire PresTaf utilise un algorithme d'Hopcroft modifié. L'ensemble des transitions menant de l'état initial vers un état final est solution de la formule. En outre si l'état final est l'état \emph{zero} alors il n'y aucune solution et si l'état final est l'état \emph{one} alors la formule est une tautologie.\\\par

Mona, est une bibliothèque C qui résout des formules monadique. La où PresTaf n'implémente à ce jour que la logique arithmétique de Presburger, la logique monadique pourrait être implémenter dans le futur.\\\par

Lash\cite{lash} est une bibliothèque C qui résout des formules de Presburger, mais la différence avec PresTaf est qu'il fonctionne sur des automates infini. Cette différence induit une importante baisse de performante. En effet PresTaf pour les mêmes formules était bien plus rapide à s'executer que Lash\cite{DBLP:conf/wia/Couvreur04}.\\\par

\section{Besoins fonctionnels}

\subsection{Prototype papier}

Le prototype qui suit serait un fichier Lua qui se servirait de la logique $Presburger$ (cette logique étant elle-même codée en Lua).

\begin{lstlisting}[mathescape=true, frame=single]
pres = require('Presburger') // Choix de la logique

local x = variable('x') // Declaration d'une variable
local y = variable('y')
local f = equals(y + integer(1), x)

// Pour exporter l'automate
f:todot("f.dot")
\end{lstlisting}

Pour lancer ce fichier Lua il faudrait passer par un fichier jar que l'on appellera $prestaf.jar$. Pour lancer le jar et le fichier lua il faudrait faire la commande suivante :

\begin{lstlisting}[mathescape=true, frame=single]
java -jar prestaf.jar fichier.lua
\end{lstlisting}

Le fichier f.dot ressemblerai à :

\begin{tikzpicture}
\node[circle,draw]           (A) at (0.75, 6)  {$q_0$};
\node[circle,draw]           (B) at (0, 4.5)   {$q_1$};
\node[circle,draw,accepting] (C) at (1.5, 4.5) {$q_2$};
\node[circle,draw,accepting] (D) at (2, 3)     {$q_3$};
\node[circle,draw]           (E) at (2, 1.5)   {$q_4$};
\node[circle,draw,accepting] (F) at (0.75, 0)  {$zero$};

\path[->] (0.75, 7) edge (A)
(A) edge [bend right] node[above]{0} (B)
(B) edge [bend right] node[right]{1} (A)
(A) edge [bend left] node[right]{1} (C)
(B) edge [bend right] node[right]{0} (F)
(C) edge [bend right] node[right]{1} (F)
(C) edge [bend right] node[right]{0} (D)
(D) edge [bend right] node[right]{0} (C)
(D) edge [bend right] node[right]{1} (E)
(E) edge [bend right] node[right]{1} (D)
(E) edge [bend left] node[right]{0} (F);
\end{tikzpicture}

\subsection{Fonctions}

La priorité des fonctions varie de 1 à 5, du plus important au moins important, sachant que la priorité 5 correspond à une fonctionnalité optionnelle.

\subsubsection{Bilbiothèque d'automate générique}

\paragraph{Description :} La bibliothèque PresTaf est générique et doit accepter toutes sortes d'automates.

\paragraph{Justification :} L'utilisateur aura la possibilité d'implémenter ses propres logiques, la bibliothèque doit donc accepter toutes logiques. En effet PresTaf sera une bibliothèque d'automates, permettant de minimiser un automate, de faire des intersections, des unions, etc. Il ne faut donc pas que PresTaf soit ciblé sur Presburger, mona ou une quelconque autre logique.

\paragraph{Priorité :} 1\\

\rule{\linewidth}{1pt}

\subsubsection{Minimisation d'automate}

\paragraph{Description :} Ensemble de fonctions qui prennent un automate (fini, complet) et déterministe en entrée et retourne l'automate minimal équivalent.

\paragraph{Justification :} Besoin initial.

\paragraph{Priorité :} 1\\

\rule{\linewidth}{1pt}

\subsubsection{Interfaçage Lua}

\paragraph{Description :} Permet le codage des automates en Lua, ainsi que l'utilisation de chaques fonctions qui seront ensuite exécutées en Java.

\paragraph{Justification :} Le lua est un langage de script simple à prendre en main et qui permet facilement d'écrire des automates et d'utiliser des fonctions.

\paragraph{Priorité :} 2\\

\rule{\linewidth}{1pt}

\subsubsection{Portabilité du code}

\paragraph{Description :} Windows, MacOS, Linux

\paragraph{Justification :} Comme java est un langage portable executé via la Java Virutal Machine (JVM), et que LuaJava est executé via java il embarque sa propre machine virtuelle, en théorie le code sera donc portable sur tous les systèmes d'exploitation. En dehors de la portabilité du code, Windows MacOs et Linux sont les principaux systèmes d'exploitation, il est donc important d'avoir un code portable pour chaque machine pour faciliter l'accès.

\paragraph{Priorité :} 1\\

\rule{\linewidth}{1pt}

\subsubsection{Optimisation}

\paragraph{Description :} La bilbiothèque d'automates PresTaf doit être rapide à s'exécuter.

\paragraph{Justification :} L'utilisateur n'aura pas le temps d'attendre quelques dizaines de minutes que son automate soit généré. Il voudra obtenir son résultat rapidement.

\paragraph{Priorité :} 5

\section{Besoins non fonctionnels}

\subsection{Fonctions}

\subsubsection{Transformation de formules arithmétiques de Presburger}

\paragraph{Description :} Ensemble de fonctions qui prennent en entrée une formule arithmétique et retourne l'automate acceptant cette formule.

\paragraph{Justification :} La bilbiothèque PresTaf n'implémentera pas d'elle-même une logique. Ainsi l'implémentation de la logique de Presburger en script Lua, permettra de fournir une démo à l'utilisateur. Il aurait un aperçu des bonnes pratiques à avoir, les méthodes qu'il se doit d'implémenter, et des fonctionnalités présentes.

\paragraph{Priorité :} 1\\

\rule{\linewidth}{1pt}

\subsubsection{Logique monadique du second ordre}

\paragraph{Description :} Il s'agit d'une logique du second ordre, c'est-à-dire qu'un prédicat peut avoir en argument un autre prédicat, mais celui-ci ne peut pas avoir un troisième prédicat en argument (arité un). De plus dans le cadre de la logique monadique du second ordre les quantificateurs ne peuvent être utilisés que pour les variables des prédicats du premier ordre (de type Presburger par exemple).

\paragraph{Justification :} La logique de Presburger est moins complète que la logique Monadique, puisque la logique Monadique propose une notion de successeur, donc en implémentant la logique Monadique dans une autre bibliothèque Lua, on fournirait d'avantage de démo à l'utilisateur.

\paragraph{Priorité :} 3\\

\rule{\linewidth}{1pt}

\subsubsection{Acceptation de formules en base -2}

\paragraph{Description :} La base -2 est défini par : $ \sum\limits_{i=0}^n (-2)^i * k_i$. Par exemple $2_{decimal} = 0 * (-2)^0 + 1 * (-2)^1 \Rightarrow 2_{decimal} = -2_{base - 2}$. Pour déterminer un nombre en base -2, il suffit de determiner son écriture binaire et ensuite d'appliquer le calcule base -2. Si l'on a le nombre $10110010_{binaire}$ alors on aura en base -2 : $0 * (-2)^0 + 1 * (-2)^1 + 0 * (-2)^2 + 0 * (-2)^3 + 1 * (-2)^4 + 1 * (-2)^5 + 0 * (-2)^6 + 1 * (-2)^7 = -146_{base - 2}$

\paragraph{Justification :} Il serait intéressant de permettre à l'utilisateur d'utiliser cette bilbiothèque avec diverses bases, surtout la base -2.

\paragraph{Priorité :} 5

\section{Prototypes et tests préparatoires}

\subsection{Blum}

Voici un exemple que nous avons testé avec l'automate initial et l'objectif.

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm,
                    semithick]

\node[circle,draw]           (A) at (2.25, 7.5) {$q_0$};
\node[circle,draw]           (B) at (2.25, 6)   {$q_1$};
\node[circle,draw]           (C) at (1.5, 4.5)  {$q_2$};
\node[circle,draw]           (D) at (3, 4.5)    {$q_3$};
\node[circle,draw]           (E) at (1.5, 3)    {$q_4$};
\node[circle,draw]           (F) at (3, 3)      {$q_5$};
\node[circle,draw]           (G) at (0, 1.5)    {$q_6$};
\node[circle,draw,accepting] (H) at (1.5, 1.5)  {$q_7$};
\node[circle,draw,accepting] (I) at (3, 1.5)    {$q_8$};
\node[circle,draw]           (J) at (4.5, 1.5)  {$q_9$};
\node[circle,draw,accepting] (K) at (0, 0)      {$q_{10}$};
\node[circle,draw,accepting] (L) at (4.5, 0)    {$q_{11}$};

\node at (6, 3.75) {$\Longrightarrow$};

\node[circle,draw]           (M) at (7.5, 1.5)       {$q_4$};
\node[circle,draw,accepting] (N) at (9, 0)           {$q_5$};
\node[circle,draw]           (O) at (9, 3)           {$q_3$};
\node[circle,draw]           (P) [above of=O]        {$q_2$};
\node[circle,draw]           (Q) [above of=P]        {$q_1$};
\node[circle,draw]           (R) [above of=Q]        {$q_0$};

\node at (2.25, 9) {Automate initial};
\node at (9, 9) {Automate minimal};

\path[->] (A) edge [right] node{0} (B)
(B) edge [bend right] node[above]{1} (C)
(B) edge [bend left] node[above]{0} (D)
(C) edge [left] node{0} (E)
(D) edge [right] node{0} (F)
(E) edge [bend right] node[above]{1} (G)
(E) edge [right] node{0} (H)
(F) edge [bend left] node[above]{1} (J)
(F) edge [left] node{0} (I)
(G) edge [left] node{0} (K)
(J) edge [right] node{0} (L)
(2.25, 8.5) edge (A)
(9, 8.5) edge (R)
(R) edge[right] node{0} (Q)
(Q) edge[bend right] node[left]{1} (P)
(Q) edge[bend left] node[right]{0} (P)
(P) edge[left] node{0} (O)
(O) edge[left] node{0} (N)
(O) edge[bend right] node[left]{1} (M)
(M) edge[bend right] node[left]{0} (N);

\end{tikzpicture}

\section{Exemple de fonctionnement}

\section{Architecture}

L'architecture de notre logiciel est composé de 4 parties:
La première partie est la bibliothqèe Prestaf qui permet de manipuler des automates et d'éffectuer des opérations dessus. Nous avons créé une interface en java qui permet d'accéder plus simplement aux fonctions de la bibliothèques.
La deuxieme partie est en Lua. Elle est composée des différentes bibliothèques de logique utilisant la bibliothèque Prestaf. Nous avons développé la bibliothèque Presburger.
La troisième partie est également en Lua. Elle contient les différents fichiers des utilisateurs des bibliothèques de logique.
La quatrième partie est en java. C'est le launcher qui permet de démarrer l'application avec une unique commande tout en permettant d'utiliser du java et du Lua.

Ainsi, la première et la quatrième couche de l'application font parties de la bibliothèque Prestaf. Il y a deux sortes d'utilisateurs. En effet, une partie des utilisateurs utiliseront directement notre bibliothèque pour développer leur propre bibliothèque de logique,
tandis que l'autre partie des utilisateurs utiliseront les bibliothèques de logique. Un utilisateur peut également être utilisateur de sa propre bibliothèque. Le premier groupe d'utilisateur travaillera essentiellement sur la 2 eme couche de l'application, 
tandis que le second groupe travaillera sur la 3 eme couche.

Pour pouvoir utiliser le code Lua en Java nous avons utilisé la bibliothèque Luajava.

\begin{tikzpicture}

\draw (6, 0.25) rectangle (10, 1.25);
\draw[color=blue!25, ultra thick] (6.5, 1) -- (7.5, 1);
\draw (8, 1) node{Java};
\draw[color=red!25, ultra thick] (6.5, 0.5) -- (7.5, 0.5);
\draw (8, 0.5) node{Lua};

\draw[fill=blue!25] (0,0) rectangle (10,-1);
\draw (5, -0.5) node{PrestafLauncher};

\draw[->,thick] (5, -1) -- (5, -2);

\draw[fill=red!25] (0, -2) rectangle (10, -3);
\draw (5, -2.5) node{LuaInterface};

\draw[fill=red!25] (0, -4) rectangle (4, -5);
\draw[fill=red!25] (6, -4) rectangle (10, -5);
\draw (2, -4.5) node{Logique};
\draw (8, -4.5) node{Presburger};

\draw[->,thick] (5, -3) -- (2, -4);
\draw[->,thick] (5, -3) -- (8, -4);

\draw[fill=blue!25] (0, -6) rectangle (10,-7);
\draw (5, -6.5) node{PresTaf};

\draw[->,thick] (2, -5) -- (5, -6);
\draw[->,thick] (8, -5) -- (5, -6);

\draw[color=orange!75!black] (-2, -0.5) node[align=center]{Bilbiothèque};
\draw[color=purple!55!black] (-2, -2.5) node[align=center]{Utilisateur\\de l'outil};
\draw[color=red!75!black] (-2, -4.5) node[align=center]{Utilisateur\\qui fait sa\\propre bibliothèque};
\draw[color=orange!75!black] (-2, -6.5) node[align=center]{Bilbiothèque};

\end{tikzpicture}

\section{Description et justification du code}

\subsection{Surcharge d'opérateurs}


L'un des principaux avantages de Lua est d'être un langage de script qui permet la surcharge d'opérateur. On peut surcharger 18 opérateurs. Nous avons donc surchargé les opérateurs + - * afin de permettre à l'utilisateur d'utiliser des opérateurs à la place de fonctions pour écrire ses formules Presburger.
Nous voulions également surcharger l'opérateur ==, cependant nous nous sommes rendus comptes que quelque soit la valeur de retour que nous mettions, elle est était toujours transformée en booléan.
Nous avons donc choisi que cet opérateur ne retournerait pas de valeur mais placerait la valeur dans une variable, il faut donc une deuxieme fonction pour l'appeler.
En Lua, on peut également créé un opérateur de la forme 'operateur'. Nous avons choisi de créer l'opérateur '=' qui retourne la bonne valeur.
L'utilisateur peut donc choisir entre l'opérateur == et l'opérateur '='.
Pour l'égalité, l'addition, la soustraction et la multiplication de Presburger, l'utilisateur peut donc utiliser la fonction associée ou utiliser l'opérateur surchargé.


\section{Analyser la compléxité}

Presburger est une surcouche de Prestaf, il est donc directement lié à la complexité de Prestaf. L'une des complexités essentielles de Prestaf est celle de la minimisation d'automate. Un automate peut en effet avoir plusieurs milliers d'états. Nous avons commencé par étudier les algorithmes d'Hopecroft et Blum qui sont en log n. La complexité de Presburger est exponentielle/expo(expo))  On sait que la complexité de Prestaf est en O(n carré)

\section{Tests de validations et fonctionnement}

\subsection{Test unitaires}

Afin de vérifier que la validié de chacune des fonctions que nous avons écrites, nous avons comparé les versions lua et java de ces fonctions sur différents exemples en affichant l'état des variables contenus dans ces fonctions.

\subsection{Test globaux}

Nous avons testé la bibliothèque Presburger sur différentes formules. Pour ce faire, nous avons comparé les graphe obtenu par la nouvelle version de Presburger et l'ancienne.

\section{Description des extensions possibles}

\subsection{Complexité}

La complexité des bibliothèques développées dépend directement de celle de Prestaf. Il serait donc intéréssant d'améliorer sa complexité.

\subsection{Diversité des bibliothèques}

Prestaf peut être amélioré en développant des bibliothèques de différentes logiques. Les possibilités à partir du même fichier LuaInterface seront donc augmentées.

\appendix

\printglossaries

\bibliography{biblio}{}
\addcontentsline{toc}{section}{Références}
\bibliographystyle{plain}

% \section{Premi\`ere annexe}

\end{document}
