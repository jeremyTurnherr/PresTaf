%% Based on a TeXnicCenter-Template by Gyorgy SZEIDL.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%------------------------------------------------------------
%
\documentclass[12pt]{article}%
%Options -- Point size:  10pt (default), 11pt, 12pt
%        -- Paper size:  letterpaper (default), a4paper, a5paper, b5paper
%                        legalpaper, executivepaper
%        -- Orientation  (portrait is the default)
%                        landscape
%        -- Print size:  oneside (default), twoside
%        -- Quality      final(default), draft
%        -- Title page   notitlepage, titlepage(default)
%        -- Columns      onecolumn(default), twocolumn
%        -- Equation numbering (equation numbers on the right is the default)
%                        leqno
%        -- Displayed equations (centered is the default)
%                        fleqn (equations start at the same distance from the right side)
%        -- Open bibliography style (closed is the default)
%                        openbib
% For instance the command
%           \documentclass[a4paper,12pt,leqno]{article}
% ensures that the paper size is a4, the fonts are typeset at the size 12p
% and the equation numbers are on the left side
%
\usepackage{amsmath}%
\usepackage{amsfonts}%
\usepackage{amssymb}%
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,automata,positioning}
\usepackage{tkz-graph}
\usepackage{cite}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{     
	colorlinks,     
	linkcolor={black},     
	citecolor={black},     
	urlcolor={black} 
}
\usepackage[toc,section=section,nonumberlist]{glossaries}
\usepackage{url}
\makeglossaries
%-------------------------------------------
\newtheorem{theorem}{Theorem}
\newtheorem{acknowledgement}[theorem]{Acknowledgement}
\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{case}[theorem]{Case}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{conclusion}[theorem]{Conclusion}\newtheorem{condition}[theorem]{Condition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{criterion}[theorem]{Criterion}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{exercise}[theorem]{Exercise}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{solution}[theorem]{Solution}
\newtheorem{summary}[theorem]{Summary}
\newenvironment{proof}[1][Proof]{\textbf{#1.} }{\ \rule{0.5em}{0.5em}}

%--------------------------------------------------------------------%
%         POUR DEFINIR DES ENTRÉES DU GLOSSAIRE LE FAIRE ICI         %
%              POUR LES ACRONYMES C'EST AU MÊME ENDROIT              %
%--------------------------------------------------------------------%

\longnewglossaryentry{presburger}{
	name=Arithmétique de Presburger
}
{
	L'arithmétique de Presburger à été introduite par Moj\.{z}esz Presburger en 1929. Cette arithmétique du premier ordre dispose de deux constantes 0 et 1 ainsi qu'un symbole binaire +. Ce langage est limité aux entiers naturels et est défini par les lois suivantes :
	\begin{enumerate}
		\item $\forall x, \neg(0 = x + 1)$
		\item $\forall x, \forall y, x + 1 = y + 1 \rightarrow x = y $
		\item $\forall x, x + 0 = x$
		\item $\forall x, \forall y, x + (y + 1) = (x + y) + 1$
		\item $\forall P(x, y_1, \ldots, y_n) \in$ Formule du premier ordre,\\
		$\forall y_1 \ldots \forall y_n [(P(0, y_1, \ldots,y_n) \vee \forall x(P(x, y_1, \ldots, y_n) \rightarrow \\P(x + 1, y_1, \ldots, y_n))) \rightarrow \forall y P(y, y_1, \ldots, y_n)]$
	\end{enumerate}
}

\longnewglossaryentry{monadique}{
	name=Logique monadique du second ordre
} {
	aussi connu sous le nom de \emph{Monadic Second Order} ou \emph{MSO}, est notamment utilisé dans un autre programme de M.Couvreur : VeriTaf. VeriTaf permet de vérifier des formules CTL (Computation Tree Logic) et des formules LTL (Linear Temporal Logic)
}

%--------------------------------------------------------------------%
%         POUR DEFINIR DES ENTRÉES DU GLOSSAIRE LE FAIRE ICI         %
%              POUR LES ACRONYMES C'EST AU MÊME ENDROIT              %
%--------------------------------------------------------------------%

\renewcommand{\headrulewidth}{1pt}
\fancyhead[C]{} 
\fancyhead[L]{\leftmark}
\fancyhead[R]{\large{\textbf{PresTaf}}}

\renewcommand{\footrulewidth}{1pt}
\fancyfoot[C]{} 
\fancyfoot[L]{\textbf{\today}}
\fancyfoot[R]{\textbf{page \thepage}}

\begin{document}
\pagestyle{empty}

\begin{titlepage}
\begin{center}
\noindent{\Huge \textbf{PresTaf}}\\
\vspace{0.5cm}
%\noindent{\LARGE \textbf{Une bibliothèque d'automate}}\\
\vspace{2cm}
{\Large Bourgeois Adrien, Marbois Bryce, Roque Maxime, Turnherr Jérémy
\\Université UFR Collégium des Sciences et Technique
\\Orléans-la-Source}\\
\vfill
{\large\today}
\end{center}
\end{titlepage}

\clearpage

\tableofcontents

\cleardoublepage

\pagestyle{fancy}

\input{resume}

\input{domaine}

\input{existant}

\input{bf}

\input{bnf}

\input{proto}

\input{exemple}

\input{architecture}

\input{desc}

\input{complex}

\input{tests}

\input{extensions}

\section{Conclusion}

Pour mener a bien ce projet, nous avons utilisé l'outil de versionnage git avec un dépôt gitHub pour favoriser un travail collaboratif et à distance. Nous avons également créé une javadoc pour l'interface de PresTaf. Celle-ci permettra aux utilisateurs de créer plus facilement leur bibliothèque. Nous avons aussi créé des script bat et sh pour simplifier le lancement du programme et éviter d'entrer une commande javac avec un classpath.
	
Nous avons répondu a plusieurs besoins:
	\begin{itemize}
\item L'utilisateur peut utiliser différentes logiques en appelant simplement la logique qu'il souhaite en début de fichier.
\item Il peut également créer sa propre logique grâce à l'interface de PresTaf et sa javadoc.
\item L'utilisateur peut maintenant écrire ses scripts en Lua pour utiliser Presburger a la place d'un fichier texte traduit par yacc
\item L'application est portable car les deux langages utilisés, java et lua le sont.
\item L'utilisateur a une interface simplifiée grâce aux opérateurs surchargés
\item La pluspart de nos algorithmes n'excèdent pas une complexité de $O(n^2)$, l'application reste donc en temps polynomiale ou exponentielle dans le cas des quantificateurs.
\end{itemize}

Ce projet nous a permi de découvrir le langage LUA qui est un langage de script permettant de surcharger les opérateurs. Nous avons également pu découvrir et comprendre des articles de recherches, notamment les algorithmes de Blum et d'Hopcroft qui visent à optimiser la complexité de la minimisation d'automate. Nous avons également appris l'existance de différentes logiques mathématiques telle que la base-2.


\appendix

%\section{Manuel utilisateur}

%Pour implémenter sa propre logique il est nécessaire de suivre une certaine démarche. La démarche sera expliqué avec la logique de Presburger

%\subsection{Fonctions à implémenter}

%Tout d'abord, une logique est un objet Lua qui sera traduit en objet Java pour PresTaf. Pour ce faire vous devrez d'abord créer votre classe Term :

%\lstinputlisting[basicstyle=\tiny]{Term.lua}

%Enfin créez votre logique

%\lstinputlisting[basicstyle=\tiny]{presburger.lua}

\printglossaries

\bibliography{biblio}{}
\addcontentsline{toc}{section}{Références}
\bibliographystyle{plain}

\end{document}
