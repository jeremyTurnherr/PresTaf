%% Based on a TeXnicCenter-Template by Gyorgy SZEIDL.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%------------------------------------------------------------
%
\documentclass{article}%
%Options -- Point size:  10pt (default), 11pt, 12pt
%        -- Paper size:  letterpaper (default), a4paper, a5paper, b5paper
%                        legalpaper, executivepaper
%        -- Orientation  (portrait is the default)
%                        landscape
%        -- Print size:  oneside (default), twoside
%        -- Quality      final(default), draft
%        -- Title page   notitlepage, titlepage(default)
%        -- Columns      onecolumn(default), twocolumn
%        -- Equation numbering (equation numbers on the right is the default)
%                        leqno
%        -- Displayed equations (centered is the default)
%                        fleqn (equations start at the same distance from the right side)
%        -- Open bibliography style (closed is the default)
%                        openbib
% For instance the command
%           \documentclass[a4paper,12pt,leqno]{article}
% ensures that the paper size is a4, the fonts are typeset at the size 12p
% and the equation numbers are on the left side
%
\usepackage{amsmath}%
\usepackage{amsfonts}%
\usepackage{amssymb}%
\usepackage{graphicx}
\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,automata}
\usepackage{tkz-graph}
\usepackage{cite}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{     
	colorlinks,     
	linkcolor={red!80},     
	citecolor={blue!100},     
	urlcolor={blue!80} 
}
\usepackage[toc,section=section]{glossaries}
\usepackage{url}
\makeglossaries
%-------------------------------------------
\newtheorem{theorem}{Theorem}
\newtheorem{acknowledgement}[theorem]{Acknowledgement}
\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{case}[theorem]{Case}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{conclusion}[theorem]{Conclusion}\newtheorem{condition}[theorem]{Condition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{criterion}[theorem]{Criterion}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{exercise}[theorem]{Exercise}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{solution}[theorem]{Solution}
\newtheorem{summary}[theorem]{Summary}
\newenvironment{proof}[1][Proof]{\textbf{#1.} }{\ \rule{0.5em}{0.5em}}

%--------------------------------------------------------------------%
%         POUR DEFINIR DES ENTRÉES DU GLOSSAIRE LE FAIRE ICI         %
%              POUR LES ACRONYMES C'EST AU MÊME ENDROIT              %
%--------------------------------------------------------------------%

\longnewglossaryentry{presburger}{
	name=Arithmétique de Presburger
}
{
	L'arithmétique de Presburger à été introduite par Moj\.{z}esz Presburger en 1929. Cette arithmétique du premier ordre dispose de deux constante 0 et 1 ainsi qu'un symbole binaire +. Ce langage est limité aux entiers naturels et est défini par les lois suivante :
	\begin{enumerate}
		\item $\forall x, \neg(0 = x + 1)$
		\item $\forall x, \forall y, x + 1 = y + 1 \rightarrow x = y $
		\item $\forall x, x + 0 = x$
		\item $\forall x, \forall y, x + (y + 1) = (x + y) + 1$
		\item $\forall P(x, y_1, \ldots, y_n) \in$ Formule du premier ordre, 
		$\forall y_1 \ldots \forall y_n [(P(0, y_1, \ldots,y_n) \vee \forall x(P(x, y_1, \ldots, y_n) \rightarrow P(x + 1, y_1, \ldots, y_n))) \rightarrow \forall y P(y, y_1, \ldots, y_n)]$
	\end{enumerate}
}

\longnewglossaryentry{monadique}{
	name=Logique monadique du second ordre
} {
	aussi connu sous le nom de \emph{Monadic Second Order} ou \emph{MSO}, est notamment utilisé dans un autre programme de M.Couvreur : VeriTaf. VeriTaf permet de vérifier des formules CTL (Computation Tree Logic) et des forumules LTL (Linear Temporal Logic)
}

%--------------------------------------------------------------------%
%         POUR DEFINIR DES ENTRÉES DU GLOSSAIRE LE FAIRE ICI         %
%              POUR LES ACRONYMES C'EST AU MÊME ENDROIT              %
%--------------------------------------------------------------------%


\begin{document}

\title{Mémoire intermédiaire PresTaf}


% Ajouter M.Couvreur ?
\author{Bourgeois Adrien, Marbois Bryce, Roque Maxime, Turnherr Jérémy%\thanks{Si l'on veut faire des annotations.}
\\Université UFR Collégium des Sciences et Technique d'Orléans-la-Source}
\date{\today}
\maketitle

% \begin{abstract}

% \end{abstract}

\clearpage

\tableofcontents

\cleardoublepage

\section{Résumé du projet}

Notre projet s'inscrit dans la mis-à-jour de PresTaf, logiciel d'analyse de formules logique et de leur transformation en automate minimal. Nous intervenons ici dans la création d'un interfaçage \href{https://fr.wikipedia.org/wiki/Lua}{Lua}, ainsi qu'une reprise du code source PresTaf pour donner une version plus optimisé, plus claire et propre.\\\par

Dans un second temps nous chercherons à intégrer de nouvelles logiques telle que la logique monadique ou encore l'interprétation des formules de Presburger en base -2.

\section{Domaine}

% Que dire

\subsection{Arithmétique de Presburger}

L'\gls{presburger} à été introduite par Moj\.{z}esz Presburger en 1929. Cette arithmétique du premier ordre dispose de deux constante 0 et 1 ainsi qu'un symbole binaire +. Ce langage est limité aux entiers naturels et est défini par les lois suivante :

\begin{enumerate}
    \item $\forall x, \neg(0 = x + 1)$
    \item $\forall x, \forall y, x + 1 = y + 1 \rightarrow x = y $
    \item $\forall x, x + 0 = x$
    \item $\forall x, \forall y, x + (y + 1) = (x + y) + 1$
    \item $\forall P(x, y_1, \ldots, y_n) \in$ Formule du premier ordre, 
    $\forall y_1 \ldots \forall y_n [(P(0, y_1, \ldots,y_n) \vee \forall x(P(x, y_1, \ldots, y_n) \rightarrow P(x + 1, y_1, \ldots, y_n))) \rightarrow \forall y P(y, y_1, \ldots, y_n)]$
\end{enumerate}

\subsection{Logique monadique du second ordre}

La \gls{monadique}, aussi connu sous le nom de \emph{Monadic Second Order} ou \emph{MSO}, est notamment utilisé dans un autre programme de M.Couvreur : VeriTaf. VeriTaf permet de vérifier des formules CTL (Computation Tree Logic) et des forumules LTL (Linear Temporal Logic)

\subsection{Automates et minimisation}

Les automates que nous utilisons sont générés à partir de la formule de Presburger ou la formule monadique passée en entrée. Cet automate est fini et deterministe. Cependant ils ne sont pas minimaux, pour se faire il faut appliquer l'algorithme d'Hopcroft\cite{hopcroft1971n}. Nous implémenteront une variante de cet algorithme, l'algorithme de Blum\cite{blum1996nlogn}. La difficulté de cet algorithme n'est pas son implémentation qui elle est très simple mais la structure de données.

\subsection{PresTaf}

PresTaf permet d'avoir une représentation visuel, sous forme d'automates, d'une formule de Presburger. En d'autres termes l'utilisateur rentre sa formule, et PresTaf lui fournit l'automate solution de sa formule. Ce programme pourrait notamment être utilisé par les étudiant de l'université.

\section{Analyse de PresTaf}

PresTaf est programme codé par M. Jean-Michel Couvreur, qui prend des formules de Presburger en entrées et les résout à l'aide d'automates minimaux. Tout d'abord il génère des automates déterministes et finis mais non minimaux. Il faut donc les minimiser, et pour se faire PresTaf utilise un algorithme d'Hopcroft modifié. L'ensemble des transitions menant de l'état initial vers un état final est solution de la formule. En outre si l'état final est l'état \emph{zero} alors il n'y aucune solution et si l'état final est l'état \emph{one} alors la formule est une tautologie.\\\par

Mona\\\par

Lash\cite{lash} est une bibliothèque C qui résout des formules de Presburger, mais la différence avec PresTaf est qu'il fonctionne sur des automates infini. Cette différence induit une importante baisse de performante. En effet PresTaf pour les mêmes formules était bien plus rapide à s'executer que Lash\cite{DBLP:conf/wia/Couvreur04}\\\par

Büchi\\\par

L'algorithme d'Hopcroft est un algorithme de minimisation d'automate fini et deterministe.\\\par

Blum

\section{Besoins fonctionnels}

\paragraph{Nom :} Transformation de formules arithmétiques de Presburger

\paragraph{Description :} Ensemble de fonctions qui prennent en entrée une formule arithmétique et retourne l'automate acceptant cette formule.

\paragraph{Justification :} Besoin initial.

\paragraph{Priorité :} 1\\

\rule{\linewidth}{1pt}

\paragraph{Nom :} Minimisation d'automate (Blum)

\paragraph{Description :} Ensemble de fonctions qui prennent un automate (fini, complet) et déterministe en entrée et retourne l'automate minimal équivalent.

\paragraph{Justification :} Besoin initial.

\paragraph{Priorité :} 1\\

\rule{\linewidth}{1pt}

\paragraph{Nom :} Interfaçage Lua

\paragraph{Description :} Permet le codage des automates en Lua, ainsi que l'utilisation de chaque fonction qui seront ensuite exécutés en Java.

\paragraph{Justification :} Le lua est un langage de script simple à prendre en main et qui permet facilement d'écrire des automates et d'utiliser des fonctions.

\paragraph{Priorité :} 2\\

\rule{\linewidth}{1pt}

\paragraph{Nom :} Acceptation de formules en base -2

\paragraph{Description :} La base -2 est défini par : $ \sum\limits_{i=0}^n (-2)^i * k_i$. Par exemple $2_{decimal} = 0 * (-2)^0 + 1 * (-2)^1 \Rightarrow 2_{decimal} = -2_{base - 2}$. Pour déterminer un nombre en base -2, il suffit de determiner son écriture binaire et ensuite d'appliqué le calcule base -2. Si l'on a le nombre $10110010_{binaire}$ alors on aura en base -2 : $0 * (-2)^0 + 1 * (-2)^1 + 0 * (-2)^2 + 0 * (-2)^3 + 1 * (-2)^4 + 1 * (-2)^5 + 0 * (-2)^6 + 1 * (-2)^7 = -146_{base - 2}$

\paragraph{Justification :}

\paragraph{Priorité :} 3\\

\rule{\linewidth}{1pt}

\paragraph{Nom :} Logique monadique du second ordre

\paragraph{Description :} Il s'agit d'une logique du second ordre, c'est-à-dire qu'un prédicat peut avoir en argument un autre prédicat, mais celui-ci ne peut pas avoir un troisième prédicat en argument (arité un). De plus dans le cadre de la logique monadique du second ordre les quantificateurs ne peuvent être utilisé que pour les variables des prédicats du premier ordre (de type Presburger par exemple).

\paragraph{Justification :}

\paragraph{Priorité :} 3

\section{Besoins non fonctionnels}

\paragraph{Nom :} Machine visée

\paragraph{Description :} Windows, MacOS, Linux

\paragraph{Justification :}

\paragraph{Priorité :} 1\\

\rule{\linewidth}{1pt}

\paragraph{Nom :} Optimisation (de PresTaf ou d'un nouveau code ?)

\paragraph{Description :}

\paragraph{Justification :}

\paragraph{Priorité :} 1

\section{Prototypes et tests préparatoires}

\subsection{Blum}

Implémentation de l'algorithme de Blum en Python.

\begin{lstlisting}

\end{lstlisting}

% Fournir les automates test -> voir à faire un automate minimal et un automate non minimal

Voici un exemple que nous avons testé avec l'automate initial et l'objectif.

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm,
                    semithick]

\node[circle,draw]           (A) at (2.25, 7.5) {$q_0$};
\node[circle,draw]           (B) at (2.25, 6)   {$q_1$};
\node[circle,draw]           (C) at (1.5, 4.5)  {$q_2$};
\node[circle,draw]           (D) at (3, 4.5)    {$q_3$};
\node[circle,draw]           (E) at (1.5, 3)    {$q_4$};
\node[circle,draw]           (F) at (3, 3)      {$q_5$};
\node[circle,draw]           (G) at (0, 1.5)    {$q_6$};
\node[circle,draw,accepting] (H) at (1.5, 1.5)  {$q_7$};
\node[circle,draw,accepting] (I) at (3, 1.5)    {$q_8$};
\node[circle,draw]           (J) at (4.5, 1.5)  {$q_9$};
\node[circle,draw,accepting] (K) at (0, 0)      {$q_{10}$};
\node[circle,draw,accepting] (L) at (4.5, 0)    {$q_{11}$};

\node at (6, 3.75) {$\Longrightarrow$};

\node[circle,draw]           (M) at (7.5, 1.5)       {$q_4$};
\node[circle,draw,accepting] (N) at (9, 0)           {$q_5$};
\node[circle,draw]           (O) at (9, 3)           {$q_3$};
\node[circle,draw]           (P) [above of=O]        {$q_2$};
\node[circle,draw]           (Q) [above of=P]        {$q_1$};
\node[circle,draw]           (R) [above of=Q]        {$q_0$};

\node at (2.25, 9) {Automate initial};
\node at (9, 9) {Automate minimal};

\path[->] (A) edge [right] node{0} (B)
(B) edge [bend right] node[above]{1} (C)
(B) edge [bend left] node[above]{0} (D)
(C) edge [left] node{0} (E)
(D) edge [right] node{0} (F)
(E) edge [bend right] node[above]{1} (G)
(E) edge [right] node{0} (H)
(F) edge [bend left] node[above]{1} (J)
(F) edge [left] node{0} (I)
(G) edge [left] node{0} (K)
(J) edge [right] node{0} (L)
(2.25, 8.5) edge (A)
(9, 8.5) edge (R)
(R) edge[right] node{0} (Q)
(Q) edge[bend right] node[left]{1} (P)
(Q) edge[bend left] node[right]{0} (P)
(P) edge[left] node{0} (O)
(O) edge[left] node{0} (N)
(O) edge[bend right] node[left]{1} (M)
(M) edge[bend right] node[left]{0} (N);

\end{tikzpicture}

% Test LuaJava

\subsection{LuaJava}

\section{Planning}

% Reunions : 10/02, 15/02, 28/02, 07/03

\begin{enumerate}
\item Implémation de l'algorithme de Blum.
\item Révision du code PresTaf.
\item Iterfaçage en Lua.
\item Rédaction du mémoire intermédiaire
\end{enumerate}


\appendix

\bibliography{biblio}{}
\bibliographystyle{plain}

\printglossaries

% \section{Premi\`ere annexe}

\end{document}
