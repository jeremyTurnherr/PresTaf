\section{Exemple de fonctionnement}

\subsection{Un logiciel souple}

Grâce à PresTaf, il est possible de passer aisément d'une logique a une autre. Nous pouvons par exemple créer simplement l'automate reconnaissant le langage $L = \{x | x = 2^n, n \in \mathbb{N} \}$. En effet, l'automate minimal n'a que 3 états.

\begin{figure}[h]

\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm,
                    semithick]

\node[circle,draw]           (A) at (0, 0) {$q_0$};
\node[circle,draw,accepting] (B) at (2.5, 0)   {$q_1$};
\node[circle,draw]           (C) at (5, 0)  {$q_2$};

\path[->] (A) edge [loop above] node{0} (A)
(A) edge node[above]{1} (B)
(B) edge [loop above] node{0} (B)
(B) edge node[above]{1} (C)
(-1, 0) edge (A)
;

\end{tikzpicture}
\caption{Automate corréspondant à $x = 2^n$}
\end{figure}

Si on associe un ensemble de variables a des booléens, cet automate permet de trouver si une variable est un singleton. Par extension on peut donc passer de la logique Monadique a la logique Presburger grâce à cet automate.


\begin{lstlisting}[mathescape=true, frame=single]
pres = require('Presburger')

local x = variable('x')
local y = variable('y')

local f = x '=' 2 * y 

f:todot("f.dot")
\end{lstlisting}

Le ficher f.dot est le suivant :

\vspace{0.5cm}

\begin{tikzpicture}

\node[circle,draw,accepting] (A) at (0, 4.5)    {$q_0$};
\node[circle,draw,accepting] (B) at (-1.5, 3)   {$q_1$};
\node[circle,draw]           (C) at (-1.5, 1.5) {$q_2$};
\node[circle,draw,accepting] (D) at (0, 0)      {$zero$};

\path[->] (0, 5.5) edge (A)
(A) edge [bend right] node[above]{0} (B)
(B) edge [bend right] node[right]{0} (A)
(B) edge [bend right] node[left]{1}  (C)
(C) edge [bend right] node[right]{1} (B)
(C) edge [bend right] node[above]{0} (D)
(A) edge [bend left]  node[right]{1} (D);
\end{tikzpicture}

Le résultat obtenus avec l'ancienne version de PresTaf est bien entendu la même. En revanche le Lua contient une différence majeure. Si l'on écrit le script suivant :

\begin{lstlisting}[mathescape=true, frame=single]
pres = require('Presburger')

local x = variable('x')
local y = variable('y')

local f = y '=' 2 * x 

f:todot("f.dot")
\end{lstlisting}

Le fichier générer sera différent : \vspace{0.5cm}

\begin{tikzpicture}

\node[circle,draw,accepting] (A) at (0, 4.5)    {$q_0$};
\node[circle,draw,accepting] (B) at (-1.5, 3)   {$q_4$};
\node[circle,draw]           (C) at (1, 3)      {$q_3$};
\node[circle,draw]           (D) at (1.5, 1.5)  {$q_1$};
\node[circle,draw]           (E) at (1, 0)      {$q_5$};
\node[circle,draw]           (F) at (3, 0)      {$q_2$};
\node[circle,draw,accepting] (G) at (0, -1.5)   {$zero$};

\path[->] (0, 5.5) edge (A)
(A) edge [bend right] node[above]{0} (B)
(B) edge [bend right] node[right]{0} (A)
(A) edge              node[left] {1} (C)
(F) edge [bend right] node[right]{1} (A)
(C) edge [bend right] node[left]{1} (G)
(C) edge              node[right]{0} (D)
(D) edge [bend left] node[right]{1} (E)
(E) edge [bend left] node[left]{1} (D)
(B) edge             node[left]{1} (G)
(D) edge             node[above]{0} (F)
(F) edge             node[below]{0} (G)
(E) edge             node[below]{0} (G);
\end{tikzpicture}

Ce qui permet de traiter les variables dans l'ordre désiré, ce qui laisse une plus grande marge de man\oe{}uvre.

Pour utiliser la bibliothèque Presburger l'utilisateur doit utiliser la fonction $require()$ de lua pour appeler les fichiers Term et Presburger.
Il existe les fonctions $variable(chaine)$ et $integer(nombre)$ qui permettent de créer respectivement une variable et un nombre. Ces deux élements peuvent ensuite manipulés à l'aide de plusieurs fonctions qui implémentent la logique de Presburger.
La pluspart de ces fonctions peuvent être également appelées directement par des opérateurs surchargés, de manière à ce que l'utilisateur puisse avoir une écriture plus lisible et concise pour écrire de très longue formules Presburger.
On trouve ainsi avec les opérateurs:
 - les opérations $factor()$ *, $plus()$ + et $minus()$ -,
 - les quantificateurs $\_A()$ 'A' et $\_E()$ 'E',
 - les comparateurs $equals()$ '=', $not\_Equals()$ !=, $greater()$ >, $greaterEquals()$ >=, $lessEquals()$ <=,$less()$ <,
 - les opérateurs logiques $and()$ \&\&, $or()$ ||, $not()$, $equiv()$ <->  et $imply()$ -> .
Voici un exemple d'utilisation pour la formule 6x+4=1\\
 
\begin{lstlisting}[mathescape=true, frame=single]
pres = require('Presburger')
local x = variable('x')
local f=(6*x+integer(4))'='(integer(1))
f:todot("f.dot")
\end{lstlisting}


