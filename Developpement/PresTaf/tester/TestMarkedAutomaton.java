////  TestMarkedAutomaton.java//  PresTaf Project////  Created by couvreur on Fri Nov 28 2003.//package tester;import prestaf.*;import java.util.Random;public class TestMarkedAutomaton {    static public void test()    {        final int N = 5;        final int MAXSIZE = 50;        final int alphabetSize = 2;        final int MAXMOD = 4;        for (int nbStates = 1; nbStates<=MAXSIZE; nbStates++) {            System.out.println("nbStates = " + nbStates);                    System.out.println("Test boolean operations");            for (int i=0; i<N; i++) {                System.out.print(".");                testBooleanOperation(nbStates, alphabetSize);            }            System.out.println();                            System.out.println("Test exists-forall");            for (int i=0; i<N; i++)            for (int mod = 1; mod<=MAXMOD; mod ++)            for (int v = 0; v<=mod; v ++) {                System.out.print(".");                testForallExists(nbStates, alphabetSize, v, mod);            }            System.out.println();                    System.out.println("Test add-exists-forall");            for (int i=0; i<N; i++)            for (int mod = 1; mod<MAXMOD; mod ++)            for (int v = 0; v<=mod; v ++) {                System.out.print(".");                testaddVariable(nbStates, alphabetSize, v, mod);            }                    System.out.println();        }    }    static public void testaddVariable(int nbStates, int alphabetSize, int v, int mod)    {        MarkedAutomaton A = SimpleMarkedAutomaton.create(nbStates,alphabetSize);        MarkedSharedAutomaton SA = MarkedSharedAutomaton.canonical(A);                    if (SA.addVariable(v,mod).exists(v,mod+1) != SA) {            System.out.println("\n v = " + v + ", mod = " + mod + "\n" + A);            throw new Error("add-exists");        }                if (SA.addVariable(v,mod).forall(v,mod+1) != SA) {            System.out.println("\n v = " + v + ", mod = " + mod + "\n" + A);            throw new Error("add-forall");        }    }        static public void testForallExists(int nbStates, int alphabetSize, int v, int mod)    {            MarkedAutomaton A = SimpleMarkedAutomaton.create(nbStates,alphabetSize);        MarkedSharedAutomaton SA = MarkedSharedAutomaton.canonical(A);                    if (SA.exists(v,mod) != SA.not().forall(v,mod).not())            throw new Error();    }    static public void testBooleanOperation(int nbStates, int alphabetSize)    {        MarkedAutomaton A = SimpleMarkedAutomaton.create(nbStates,alphabetSize);        MarkedAutomaton B = SimpleMarkedAutomaton.create(nbStates,alphabetSize);        MarkedAutomaton C = SimpleMarkedAutomaton.create(nbStates,alphabetSize);        MarkedSharedAutomaton SA = MarkedSharedAutomaton.canonical(A);        MarkedSharedAutomaton SB = MarkedSharedAutomaton.canonical(B);        MarkedSharedAutomaton SC = MarkedSharedAutomaton.canonical(C);                if (SA.zero != SA.and(SA.not()))            throw new Error("a . !a = 0");                if ((SA.and(SB)).and(SC) != SA.and(SB.and(SC)))            throw new Error("(a .b).c = a.(b.c)");        if ((SA.and(SB)).and(SA.not()) != SA.zero)            throw new Error("(a .b).!a = 0");        if ((SA.and(SB)).and(SA) != SA.and(SB))            throw new Error("(a .b).a = a.b");                        if (SA.and(SB.or(SC)) != (SA.and(SB)).or(SA.and(SC))  )            throw new Error("a.(b+c) = a.b+a.c");        if (SA.or(SB.and(SC)) != (SA.or(SB)).and(SA.or(SC))  )            throw new Error("a.(b+c) = a.b+a.c");                        if (SA.or(SB) != ((SA.not()).and(SB.not())).not() )            throw new Error("a+b = !(!a.!b)");        if (SA.and(SB) != ((SA.not()).or(SB.not())).not() )            throw new Error("a.b = !(!a+!b)");                    if (SA.imply(SB) != ((SA.not()).or(SB)))            throw new Error("a->b = !a+b");        if (SA.equiv(SB) != (SA.imply(SB)).and(SB.imply(SA)))            throw new Error("a<->b = (a->b) . (b->a)");                        if (PresTafSystem.localCacheSize() != 0)            throw new Error("local cache");    }            static public void testSimple()    {        int initial = 0;        boolean[] isFinal = {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false};        int[][] succ = { 	 { 19,0 },	 { 18,1 },	 { 14,4 },	 { 24,12 },	 { 3,2 },	 { 5,1 },	 { 7,10 },	 { 25,11 },	 { 14,8 },	 { 24,26 },	 { 12,8 },	 { 7,17 },	 { 20,15 },	 { 17,22 },	 { 25,3 },	 { 12,26 },	 { 7,1 },	 { 13,5 },	 { 19,26 },	 { 3,20 },	 { 13,19 },	 { 18,26 },	 { 18,12 },	 { 22,23 },	 { 12,13 },	 { 23,21 },	 { 16,9 }        };        MarkedAutomaton A = new SimpleMarkedAutomaton(initial,succ,isFinal);        try {            MarkedSharedAutomaton S = MarkedSharedAutomaton.canonical(A);         }        catch(Throwable e) {            System.out.println(e.toString());            System.out.println(A.toString());                    }    }        static public void testCanonique()    {        final int N = 100000;        final int T = 20;                for (int i=0; i<N;i++) {            System.out.print(".");            SimpleMarkedAutomaton A = SimpleMarkedAutomaton.create(2,2);            SimpleMarkedAutomaton B = A.duplicate(T);            MarkedSharedAutomaton SA = MarkedSharedAutomaton.canonical(A);            MarkedSharedAutomaton SB = MarkedSharedAutomaton.canonical(B);                        if (SA!=SB)                throw new Error();        }    }}/************************ test simple *********************//*    static boolean[] isFinal = {false, false, true, true, true};    static int[][] succ = { 	 { 4,1 },	 { 2,3 },	 { 2,0 },	 { 4,3 },	 { 4,3 }    };       static boolean[] isFinal = {true, false, true, false, false};    static int[][] succ = { 	 { 0,2 },	 { 0,2 },	 { 3,0 },	 { 4,3 },	 { 3,3 }    };    static boolean[] isFinal = {true, true, false, true, true};    static int[][] succ = { 	 { 1,0 },	 { 3,3 },	 { 3,3 },	 { 2,2 },	 { 4,0 }    };        static boolean[] isFinal = {false, false, true, false, false};    static int[][] succ = { 	 { 3,3 },	 { 0,1 },	 { 2,4 },	 { 4,2 },	 { 4,2 }    };      static boolean[] isFinal = {true, false, true, true, true};    static int[][] succ = { 	 { 2,2 },	 { 1,1 },	 { 1,3 },	 { 0,0 },	 { 4,0 }    };    static boolean[] isFinal = {true, true, false, true, false};    static int[][] succ = { 	 { 2,1 },	 { 2,0 },	 { 2,2 },	 { 2,4 },	 { 0,0 }    };*//********************** test Canonical ***************************//*static int initial = 0;static boolean[] isFinal = {true, true, false, false, true, true};static int[][] succ = { 	 { 4,4 },	 { 3,2 },	 { 2,0 },	 { 2,1 },	 { 5,5 },	 { 3,5 }};static int initialB = 0;static boolean[] isFinalB = {true, true, true, true, true, true, true, true, false, true, false};static int[][] succB = { 	 { 3,1 },	 { 7,7 },	 { 3,1 },	 { 7,5 },	 { 10,8 },	 { 10,7 },	 { 10,8 },	 { 10,7 },	 { 8,2 },	 { 10,9 },	 { 8,4 }};static int initial = 0;static boolean[] isFinal = {true, false, false, true, true, true};static int[][] succ = { 	 { 2,1 },	 { 5,0 },	 { 4,3 },	 { 3,1 },	 { 1,3 },	 { 3,4 }};static int initialB = 0;static boolean[] isFinalB = {true, true, true, true, false, true, false, true, true, true, true};static int[][] succB = { 	 { 6,4 },	 { 4,8 },	 { 6,4 },	 { 4,10 },	 { 7,2 },	 { 8,1 },	 { 1,10 },	 { 10,1 },	 { 8,4 },	 { 8,3 },	 { 8,4 }};*/